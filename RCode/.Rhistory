data_no_outlier <- subset(as.data.frame(MLE.closeform)$tao_hat, as.data.frame(MLE.closeform)$tao_hat > quartiles[1] - 1.5*IQR & as.data.frame(MLE.closeform)$tao_hat < quartiles[2] + 1.5*IQR)
MLE.closeform$name
as.data.frame(MLE.closeform)$name
View(MLE.closeform)
colnames(MLE.closeform)[1]
for (col in colnames(MLE.closeform)){print(col)}
as.data.frame(MLE.closeform)$col
for (col in colnames(MLE.closeform)){
idx=colnames(MLE.closeform)[which(colnames(MLE.closeform) == col)]
print(idx)
}
for (col in colnames(MLE.closeform)){
idx=which(colnames(MLE.closeform) == col)
print(idx)
}
MLE.closeform[1]
as.data.frame(MLE.closeform)[1]
for (col in colnames(MLE.closeform)){
idx=which(colnames(MLE.closeform) == col)
quartiles <- quantile(as.data.frame(MLE.closeform)[idx], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(as.data.frame(MLE.closeform)[idx])
MLE.cf_no_outlier <- subset(as.data.frame(MLE.closeform)[idx], as.data.frame(MLE.closeform)[idx] > quartiles[1] - 1.5*IQR & as.data.frame(MLE.closeform)[idx] < quartiles[2] + 1.5*IQR)
}
as.data.frame(MLE.closeform)$name
colnames(MLE.closeform)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
colnames(MLE.optim)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
View(MLE.optim)
MLE.closeform[1]
MLE.closeform[1]
quantile(as.data.frame(MLE.closeform)[1], probs=c(.25, .75), na.rm = FALSE)
as.data.frame(MLE.closeform)[1]
temp<-as.data.frame(MLE.closeform)
quartiles <- quantile(temp[1], probs=c(.25, .75), na.rm = FALSE)
temp<-as.data.frame(MLE.closeform)[1]
quartiles <- quantile(temp, probs=c(.25, .75), na.rm = FALSE)
temp<-MLE.closeform$tao_hat
MLE.cf_no_outlier <-matrix()
MLE.cf_no_outlier <-matrix()
for (col in colnames(MLE.closeform)){
#idx=which(colnames(MLE.closeform) == col)
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- cbind(MLE.cf_no_outlier,subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR))
}
View(MLE.cf_no_outlier)
MLE.cf_no_outlier <-matrix()
for (col in colnames(MLE.closeform)){
#idx=which(colnames(MLE.closeform) == col)
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR)
print(length(MLE.cf_no_outlier))
#MLE.cf_no_outlier <- cbind(MLE.cf_no_outlier,subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR))
}
MLE.closeform[,col] > quartiles[1] - 1.5*IQR
quartiles[1] - 1.5*IQR
quartiles[1]
IQR
col=tao_hat
col='tao_hat'
#idx=which(colnames(MLE.closeform) == col)col='tao_hat'
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR)
num=1.5
while (length(MLE.cf_no_outlier)<1986){
num=num+0.1
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - num*IQR & MLE.closeform[,col] < quartiles[2] + num*IQR)
}
length(MLE.cf_no_outlier)
num=1.5
while (length(MLE.cf_no_outlier)<1986){
num=num+0.1
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - num*IQR & MLE.closeform[,col] < quartiles[2] + num*IQR)
print(num)
}
num=1.5
while (length(MLE.cf_no_outlier)>1986){
num=num+0.1
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - num*IQR & MLE.closeform[,col] < quartiles[2] + num*IQR)
print(num)
}
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 2*IQR & MLE.closeform[,col] < quartiles[2] + 2*IQR)
length(MLE.cf_no_outlier)
col='tao_hat'
MLE.cf_no_outlier <-matrix()
#idx=which(colnames(MLE.closeform) == col)col='tao_hat'
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR)
MLE.cf_no_outlier <-matrix()
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 2*IQR & MLE.closeform[,col] < quartiles[2] + 2*IQR)
print(num)
length(MLE.cf_no_outlier)
MLE.cf_no_outlier <-matrix()
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1*IQR & MLE.closeform[,col] < quartiles[2] + 1*IQR)
length(MLE.cf_no_outlier)
MLE.cf_no_outlier <-matrix()
num=1.5
while (length(MLE.cf_no_outlier)>1986){
num=num-0.1
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - num*IQR & MLE.closeform[,col] < quartiles[2] + num*IQR)
print(num)
length(MLE.cf_no_outlier)
}
#idx=which(colnames(MLE.closeform) == col)col='tao_hat'
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - 1.5*IQR & MLE.closeform[,col] < quartiles[2] + 1.5*IQR)
num=1.5
while (length(MLE.cf_no_outlier)>1986){
num=num-0.1
quartiles <- quantile(MLE.closeform[,col], probs=c(.25, .75), na.rm = FALSE)
IQR <- IQR(MLE.closeform[,col])
MLE.cf_no_outlier <- subset(MLE.closeform[,col], MLE.closeform[,col] > quartiles[1] - num*IQR & MLE.closeform[,col] < quartiles[2] + num*IQR)
print(num)
length(MLE.cf_no_outlier)
}
length(MLE.cf_no_outlier)
MLE.cf_no_outlier<-apply(MLE.closeform, 2, sort)
MLE.cf_no_outlier <- slice(MLE.cf_no_outlier, 11:(n() - 10))
install.packages("dplyr")                 # Install dplyr package
install.packages("dplyr")
library("dplyr")
MLE.cf_no_outlier <- slice(MLE.cf_no_outlier, 11:(n() - 10))
install.packages("dplyr")                 # Install dplyr package
library("dplyr")
MLE.cf_no_outlier <- slice(MLE.cf_no_outlier, 11:(n() - 10))
View(MLE.cf_no_outlier)
View(MLE.cf_no_outlier)
(length(MLE.cf_no_outlier) - 10)
nrow(MLE.cf_no_outlier) - 10
MLE.cf_no_outlier <- MLE.cf_no_outlier[11:(nrow(MLE.cf_no_outlier) - 10),]
View(MLE.cf_no_outlier)
View(MLE.cf_no_outlier)
set.seed(110225021)
setwd("C:/Github/Study_CrossoverDesign/RCode")
sim_time=2000
seq_size<-c(25,50,100,200)
cor_param=0.1
cros_type='ABBA'
#tao,eta,gamma,delta
params = matrix(c(1.0, 0.7, 0.3, 0.2), nrow=1,ncol=4)
#link of mean.i11,mean.mean.i12,mean.i21,mean.22
x.mat  <-  matrix(c(1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1), nrow = 4, ncol = 4)
mean_true=exp(params%*%x.mat)
pi=0.5#(seq_size)/(seq_size*2)
I.true<- matrix(0, nrow = 4, ncol = 4)
for (i in 1:length(params) ){ I.true[i,]<-0.5*mean_true%*%(t(x.mat)*x.mat[i,])}
#the form of matrix that export to excel
#output object
obj<-c('MLE.optim','MLE.closeform','I.hat.hessian','I.hat','V.hat.matix','inv(I.hat)','NS.MLE.optim','NS.MLE.closeform')
#name of output object
space<-matrix(c('','',''), nrow=1,ncol = 3)
obj.names<-matrix(0,ncol = 4,length(obj))
for (i in 1:length(obj)){obj.names[i,]<-cbind(obj[i],space)}
result <- list()#to store result of each seq_size
#use optim to obtain MLE、I_hat、V_hat
for (seq in seq_size){
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
I.optim=0
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
I.hat<- 0
V.hat<- 0
for (i in 1:sim_time){
pi=(seq)/(seq*2)
data <-  matrix(0, nrow = seq, ncol = 4)
for (j in 1:length(mean_true)) {data[,j] =rpois(seq, lambda = mean_true[1,j])}
negll <- function(param) { sum(factorial(data))
-sum( param[1]*data[,1]-exp(param[1])+sum(param[1:3])*data[,2]-exp(sum(param[1:3]))+(param[1]+param[2]+param[4])*data[,3]-exp(param[1]+param[2]+param[4])+(param[1]+param[3]+param[4])*data[,4]-exp(param[1]+param[3]+param[4]) )}
ABBA<-optim(param <- c(0.95, 0.65, 0.25, 0.15), negll, hessian=TRUE)
MLE.optim[i,]<-ABBA$par
I.optim <-I.optim+ABBA$hessian
y.sum=colSums(data)
tao.hat=log(y.sum[1]/seq)
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
mean_est<-exp(MLE.i%*%x.mat)
I.hat.i<- matrix(0, nrow = 4, ncol = 4)
V.hat.i<- matrix(0, nrow = 4, ncol = 4)
score<- matrix(0, nrow = seq, ncol = 4)
for (k in 1:length(params) ){
I.hat.i[k,]<-pi*mean_est%*%(t(x.mat)*x.mat[k,])
score[,k]<-sweep(data, 2, mean_est[1,])%*%x.mat[k,]
V.hat.i[k,]<- colSums(score*score[,k])/(seq*2)
}
MLE.closeform[i,]<- MLE.i
I.hat<-I.hat+I.hat.i
V.hat<-V.hat+V.hat.i
colnames(MLE.optim)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
colnames(MLE.closeform)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
#remove outlier of MLE.closeform
MLE.closeform<-apply(MLE.closeform, 2, sort)
MLE.closeform <- MLE.cf_no_outlier[11:(nrow(MLE.cf_no_outlier) - 10),]
#store result in MATS for seq
MATS <- list(signif(t(as.matrix(colMeans(MLE.optim))),5),signif(t(as.matrix(colMeans(MLE.closeform))),5),signif(I.optim/(sim_time*seq*2),5),signif(I.hat/sim_time,5),signif(V.hat/sim_time,5),signif(cov(MLE.optim)*seq*2,5),signif(cov(MLE.closeform)*seq*2,5),signif(solve(I.hat/sim_time),5))
#format result that we want to show in excel
seq.result<-matrix(c('tao_hat','eta_hat','gamma_hat','delta_hat'),ncol = 4,nrow = 1)
for (i in 1:length(obj)){
temp<-rbind(obj.names[i,],MATS[[i]])
seq.result<-rbind(seq.result,temp)}
}
#store result of all seq_size
num=seq_size[which(seq_size == seq)]
result <- append(result, list( num = seq.result))
}
set.seed(110225021)
setwd("C:/Github/Study_CrossoverDesign/RCode")
sim_time=2000
seq_size<-c(25,50,100,200)
cor_param=0.1
cros_type='ABBA'
#tao,eta,gamma,delta
params = matrix(c(1.0, 0.7, 0.3, 0.2), nrow=1,ncol=4)
#link of mean.i11,mean.mean.i12,mean.i21,mean.22
x.mat  <-  matrix(c(1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1), nrow = 4, ncol = 4)
mean_true=exp(params%*%x.mat)
pi=0.5#(seq_size)/(seq_size*2)
I.true<- matrix(0, nrow = 4, ncol = 4)
for (i in 1:length(params) ){ I.true[i,]<-0.5*mean_true%*%(t(x.mat)*x.mat[i,])}
#the form of matrix that export to excel
#output object
obj<-c('MLE.optim','MLE.closeform','I.hat.hessian','I.hat','V.hat.matix','inv(I.hat)','NS.MLE.optim','NS.MLE.closeform')
#name of output object
space<-matrix(c('','',''), nrow=1,ncol = 3)
obj.names<-matrix(0,ncol = 4,length(obj))
for (i in 1:length(obj)){obj.names[i,]<-cbind(obj[i],space)}
result <- list()#to store result of each seq_size
#use optim to obtain MLE、I_hat、V_hat
for (seq in seq_size){
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
I.optim=0
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
I.hat<- 0
V.hat<- 0
for (i in 1:sim_time){
pi=(seq)/(seq*2)
data <-  matrix(0, nrow = seq, ncol = 4)
for (j in 1:length(mean_true)) {data[,j] =rpois(seq, lambda = mean_true[1,j])}
negll <- function(param) { sum(factorial(data))
-sum( param[1]*data[,1]-exp(param[1])+sum(param[1:3])*data[,2]-exp(sum(param[1:3]))+(param[1]+param[2]+param[4])*data[,3]-exp(param[1]+param[2]+param[4])+(param[1]+param[3]+param[4])*data[,4]-exp(param[1]+param[3]+param[4]) )}
ABBA<-optim(param <- c(0.95, 0.65, 0.25, 0.15), negll, hessian=TRUE)
MLE.optim[i,]<-ABBA$par
I.optim <-I.optim+ABBA$hessian
y.sum=colSums(data)
tao.hat=log(y.sum[1]/seq)
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
mean_est<-exp(MLE.i%*%x.mat)
I.hat.i<- matrix(0, nrow = 4, ncol = 4)
V.hat.i<- matrix(0, nrow = 4, ncol = 4)
score<- matrix(0, nrow = seq, ncol = 4)
for (k in 1:length(params) ){
I.hat.i[k,]<-pi*mean_est%*%(t(x.mat)*x.mat[k,])
score[,k]<-sweep(data, 2, mean_est[1,])%*%x.mat[k,]
V.hat.i[k,]<- colSums(score*score[,k])/(seq*2)
}
MLE.closeform[i,]<- MLE.i
I.hat<-I.hat+I.hat.i
V.hat<-V.hat+V.hat.i
colnames(MLE.optim)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
colnames(MLE.closeform)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
#remove outlier of MLE.closeform
MLE.closeform<-apply(MLE.closeform, 2, sort)
MLE.closeform <- MLE.closeform[11:(nrow(MLE.cf_no_outlier) - 10),]
#store result in MATS for seq
MATS <- list(signif(t(as.matrix(colMeans(MLE.optim))),5),signif(t(as.matrix(colMeans(MLE.closeform))),5),signif(I.optim/(sim_time*seq*2),5),signif(I.hat/sim_time,5),signif(V.hat/sim_time,5),signif(cov(MLE.optim)*seq*2,5),signif(cov(MLE.closeform)*seq*2,5),signif(solve(I.hat/sim_time),5))
#format result that we want to show in excel
seq.result<-matrix(c('tao_hat','eta_hat','gamma_hat','delta_hat'),ncol = 4,nrow = 1)
for (i in 1:length(obj)){
temp<-rbind(obj.names[i,],MATS[[i]])
seq.result<-rbind(seq.result,temp)}
}
#store result of all seq_size
num=seq_size[which(seq_size == seq)]
result <- append(result, list( num = seq.result))
}
set.seed(110225021)
setwd("C:/Github/Study_CrossoverDesign/RCode")
sim_time=2000
seq_size<-c(25,50,100,200)
cor_param=0.1
cros_type='ABBA'
#tao,eta,gamma,delta
params = matrix(c(1.0, 0.7, 0.3, 0.2), nrow=1,ncol=4)
#link of mean.i11,mean.mean.i12,mean.i21,mean.22
x.mat  <-  matrix(c(1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1), nrow = 4, ncol = 4)
mean_true=exp(params%*%x.mat)
pi=0.5#(seq_size)/(seq_size*2)
I.true<- matrix(0, nrow = 4, ncol = 4)
for (i in 1:length(params) ){ I.true[i,]<-0.5*mean_true%*%(t(x.mat)*x.mat[i,])}
#the form of matrix that export to excel
#output object
obj<-c('MLE.optim','MLE.closeform','I.hat.hessian','I.hat','V.hat.matix','inv(I.hat)','NS.MLE.optim','NS.MLE.closeform')
#name of output object
space<-matrix(c('','',''), nrow=1,ncol = 3)
obj.names<-matrix(0,ncol = 4,length(obj))
for (i in 1:length(obj)){obj.names[i,]<-cbind(obj[i],space)}
result <- list()#to store result of each seq_size
#use optim to obtain MLE、I_hat、V_hat
for (seq in seq_size){
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
I.optim=0
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
I.hat<- 0
V.hat<- 0
for (i in 1:sim_time){
pi=(seq)/(seq*2)
data <-  matrix(0, nrow = seq, ncol = 4)
for (j in 1:length(mean_true)) {data[,j] =rpois(seq, lambda = mean_true[1,j])}
negll <- function(param) { sum(factorial(data))
-sum( param[1]*data[,1]-exp(param[1])+sum(param[1:3])*data[,2]-exp(sum(param[1:3]))+(param[1]+param[2]+param[4])*data[,3]-exp(param[1]+param[2]+param[4])+(param[1]+param[3]+param[4])*data[,4]-exp(param[1]+param[3]+param[4]) )}
ABBA<-optim(param <- c(0.95, 0.65, 0.25, 0.15), negll, hessian=TRUE)
MLE.optim[i,]<-ABBA$par
I.optim <-I.optim+ABBA$hessian
y.sum=colSums(data)
tao.hat=log(y.sum[1]/seq)
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
mean_est<-exp(MLE.i%*%x.mat)
I.hat.i<- matrix(0, nrow = 4, ncol = 4)
V.hat.i<- matrix(0, nrow = 4, ncol = 4)
score<- matrix(0, nrow = seq, ncol = 4)
for (k in 1:length(params) ){
I.hat.i[k,]<-pi*mean_est%*%(t(x.mat)*x.mat[k,])
score[,k]<-sweep(data, 2, mean_est[1,])%*%x.mat[k,]
V.hat.i[k,]<- colSums(score*score[,k])/(seq*2)
}
MLE.closeform[i,]<- MLE.i
I.hat<-I.hat+I.hat.i
V.hat<-V.hat+V.hat.i
colnames(MLE.optim)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
colnames(MLE.closeform)<-c('tao_hat','eta_hat','gamma_hat','delta_hat')
#remove outlier of MLE.closeform
MLE.closeform<-apply(MLE.closeform, 2, sort)
MLE.closeform <- MLE.closeform[11:(nrow(MLE.closeform) - 10),]
#store result in MATS for seq
MATS <- list(signif(t(as.matrix(colMeans(MLE.optim))),5),signif(t(as.matrix(colMeans(MLE.closeform))),5),signif(I.optim/(sim_time*seq*2),5),signif(I.hat/sim_time,5),signif(V.hat/sim_time,5),signif(cov(MLE.optim)*seq*2,5),signif(cov(MLE.closeform)*seq*2,5),signif(solve(I.hat/sim_time),5))
#format result that we want to show in excel
seq.result<-matrix(c('tao_hat','eta_hat','gamma_hat','delta_hat'),ncol = 4,nrow = 1)
for (i in 1:length(obj)){
temp<-rbind(obj.names[i,],MATS[[i]])
seq.result<-rbind(seq.result,temp)}
}
#store result of all seq_size
num=seq_size[which(seq_size == seq)]
result <- append(result, list( num = seq.result))
}
set.seed(110225021)
setwd("C:/Github/Study_CrossoverDesign/RCode")
sim_time=2000
seq_size<-c(25,50,100,200)
cor_param=0.1
cros_type='ABBA'
#tao,eta,gamma,delta
params = matrix(c(1.0, 0.7, 0.3, 0.2), nrow=1,ncol=4)
#link of mean.i11,mean.mean.i12,mean.i21,mean.22
x.mat  <-  matrix(c(1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1), nrow = 4, ncol = 4)
mean_true=exp(params%*%x.mat)
pi=0.5#(seq_size)/(seq_size*2)
I.true<- matrix(0, nrow = 4, ncol = 4)
for (i in 1:length(params) ){ I.true[i,]<-0.5*mean_true%*%(t(x.mat)*x.mat[i,])}
#the form of matrix that export to excel
#output object
obj<-c('MLE.optim','MLE.closeform','I.hat.hessian','I.hat','V.hat.matix','inv(I.hat)','NS.MLE.optim','NS.MLE.closeform')
#name of output object
space<-matrix(c('','',''), nrow=1,ncol = 3)
obj.names<-matrix(0,ncol = 4,length(obj))
for (i in 1:length(obj)){obj.names[i,]<-cbind(obj[i],space)}
result <- list()#to store result of each seq_size
#use optim to obtain MLE、I_hat、V_hat
for (seq in seq_size){
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
I.optim=0
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
I.hat<- 0
V.hat<- 0
for (i in 1:sim_time){
pi=(seq)/(seq*2)
data <-  matrix(0, nrow = seq, ncol = 4)
for (j in 1:length(mean_true)) {data[,j] =rpois(seq, lambda = mean_true[1,j])}
negll <- function(param) { sum(factorial(data))
-sum( param[1]*data[,1]-exp(param[1])+sum(param[1:3])*data[,2]-exp(sum(param[1:3]))+(param[1]+param[2]+param[4])*data[,3]-exp(param[1]+param[2]+param[4])+(param[1]+param[3]+param[4])*data[,4]-exp(param[1]+param[3]+param[4]) )}
ABBA<-optim(param <- c(0.95, 0.65, 0.25, 0.15), negll, hessian=TRUE)
MLE.optim[i,]<-ABBA$par
I.optim <-I.optim+ABBA$hessian
y.sum=colSums(data)
tao.hat=log(y.sum[1]/seq)
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
mean_est<-exp(MLE.i%*%x.mat)
I.hat.i<- matrix(0, nrow = 4, ncol = 4)
V.hat.i<- matrix(0, nrow = 4, ncol = 4)
score<- matrix(0, nrow = seq, ncol = 4)
for (k in 1:length(params) ){
I.hat.i[k,]<-pi*mean_est%*%(t(x.mat)*x.mat[k,])
score[,k]<-sweep(data, 2, mean_est[1,])%*%x.mat[k,]
V.hat.i[k,]<- colSums(score*score[,k])/(seq*2)
}
MLE.closeform[i,]<- MLE.i
I.hat<-I.hat+I.hat.i
V.hat<-V.hat+V.hat.i
}
#remove outlier of MLE.closeform
MLE.closeform<-apply(MLE.closeform, 2, sort)
MLE.closeform <- MLE.closeform[11:(nrow(MLE.closeform) - 10),]
#store result in MATS for seq
MATS <- list(signif(t(as.matrix(colMeans(MLE.optim))),5),signif(t(as.matrix(colMeans(MLE.closeform))),5),signif(I.optim/(sim_time*seq*2),5),signif(I.hat/sim_time,5),signif(V.hat/sim_time,5),signif(cov(MLE.optim)*seq*2,5),signif(cov(MLE.closeform)*seq*2,5),signif(solve(I.hat/sim_time),5))
#format result that we want to show in excel
seq.result<-matrix(c('tao_hat','eta_hat','gamma_hat','delta_hat'),ncol = 4,nrow = 1)
for (i in 1:length(obj)){
temp<-rbind(obj.names[i,],MATS[[i]])
seq.result<-rbind(seq.result,temp)}
#store result of all seq_size
num=seq_size[which(seq_size == seq)]
result <- append(result, list( num = seq.result))
}
write.xlsx(result, file = paste0(Sys.Date(),'.xlsx'))
set.seed(110225021)
setwd("C:/Github/Study_CrossoverDesign/RCode")
sim_time=2000
seq_size<-c(25,50,100,200)
cor_param=0.1
cros_type='ABBA'
#tao,eta,gamma,delta
params = matrix(c(1.0, 0.7, 0.3, 0.2), nrow=1,ncol=4)
#link of mean.i11,mean.mean.i12,mean.i21,mean.22
x.mat  <-  matrix(c(1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1), nrow = 4, ncol = 4)
mean_true=exp(params%*%x.mat)
pi=0.5#(seq_size)/(seq_size*2)
I.true<- matrix(0, nrow = 4, ncol = 4)
for (i in 1:length(params) ){ I.true[i,]<-0.5*mean_true%*%(t(x.mat)*x.mat[i,])}
#the form of matrix that export to excel
#output object
obj<-c('MLE.optim','MLE.closeform','I.hat.hessian','I.hat','V.hat.matix','NS.MLE.optim','NS.MLE.closeform','inv(I.hat)')
#name of output object
space<-matrix(c('','',''), nrow=1,ncol = 3)
obj.names<-matrix(0,ncol = 4,length(obj))
for (i in 1:length(obj)){obj.names[i,]<-cbind(obj[i],space)}
result <- list()#to store result of each seq_size
#use optim to obtain MLE、I_hat、V_hat
for (seq in seq_size){
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
I.optim=0
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
I.hat<- 0
V.hat<- 0
for (i in 1:sim_time){
pi=(seq)/(seq*2)
data <-  matrix(0, nrow = seq, ncol = 4)
for (j in 1:length(mean_true)) {data[,j] =rpois(seq, lambda = mean_true[1,j])}
negll <- function(param) { sum(factorial(data))
-sum( param[1]*data[,1]-exp(param[1])+sum(param[1:3])*data[,2]-exp(sum(param[1:3]))+(param[1]+param[2]+param[4])*data[,3]-exp(param[1]+param[2]+param[4])+(param[1]+param[3]+param[4])*data[,4]-exp(param[1]+param[3]+param[4]) )}
ABBA<-optim(param <- c(0.95, 0.65, 0.25, 0.15), negll, hessian=TRUE)
MLE.optim[i,]<-ABBA$par
I.optim <-I.optim+ABBA$hessian
y.sum=colSums(data)
tao.hat=log(y.sum[1]/seq)
eta.hat=0.5*(log(y.sum[2])+log(y.sum[3])-log(y.sum[1])-log(y.sum[4]))
gamma.hat=0.5*(log(y.sum[2])+log(y.sum[4])-log(y.sum[1])-log(y.sum[3]))
delta.hat=0.5*(log(y.sum[3])+log(y.sum[4])-log(y.sum[1])-log(y.sum[2]))
MLE.i = matrix(c(tao.hat, eta.hat, gamma.hat, delta.hat), nrow=1,ncol=4)
mean_est<-exp(MLE.i%*%x.mat)
I.hat.i<- matrix(0, nrow = 4, ncol = 4)
V.hat.i<- matrix(0, nrow = 4, ncol = 4)
score<- matrix(0, nrow = seq, ncol = 4)
for (k in 1:length(params) ){
I.hat.i[k,]<-pi*mean_est%*%(t(x.mat)*x.mat[k,])
score[,k]<-sweep(data, 2, mean_est[1,])%*%x.mat[k,]
V.hat.i[k,]<- colSums(score*score[,k])/(seq*2)
}
MLE.closeform[i,]<- MLE.i
I.hat<-I.hat+I.hat.i
V.hat<-V.hat+V.hat.i
}
#remove outlier of MLE.closeform
#MLE.closeform<-apply(MLE.closeform, 2, sort)
#MLE.closeform <- MLE.closeform[11:(nrow(MLE.closeform) - 10),]
#store result in MATS for seq
MATS <- list(signif(t(as.matrix(colMeans(MLE.optim))),5),signif(t(as.matrix(colMeans(MLE.closeform))),5),signif(I.optim/(sim_time*seq*2),5),signif(I.hat/sim_time,5),signif(V.hat/sim_time,5),signif(cov(MLE.optim)*seq*2,5),signif(cov(MLE.closeform)*seq*2,5),signif(solve(I.hat/sim_time),5))
#format result that we want to show in excel
seq.result<-matrix(c('tao_hat','eta_hat','gamma_hat','delta_hat'),ncol = 4,nrow = 1)
for (i in 1:length(obj)){
temp<-rbind(obj.names[i,],MATS[[i]])
seq.result<-rbind(seq.result,temp)}
#store result of all seq_size
num=seq_size[which(seq_size == seq)]
result <- append(result, list( num = seq.result))
}
write.xlsx(result, file = paste0(Sys.Date(),'.xlsx'))
