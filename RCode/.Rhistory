install.packages("xlsx")
knitr::opts_chunk$set(echo = TRUE)
library(zoo)
library(xts)
library(TTR)
library(quantmod)
library(ggplot2)
library(magrittr)
library(broom)
library(qpcR)
library(fpp2)
getSymbols("^GSPC", from ='2012-10-12', to = '2022-10-12')
SP500<-as.xts(data.frame(GSPC = GSPC[, "GSPC.Adjusted"]))
names(SP500) = c("SP500")
index(SP500) = as.Date(index(SP500))
logrt.SP500<-apply( log(SP500) , 2 , diff )*100
rt.SP500<-(exp(apply( log(SP500) , 2 , diff ))-1)*100
getSymbols("^TWII", from = '2012-10-12', to = '2022-10-12')
TWII<-as.xts(data.frame(TWII = TWII[, "TWII.Adjusted"]))
TWII<-na.omit(TWII)
names(TWII) = c("TWII")
index(TWII) = as.Date(index(TWII))
logrt.TWII<-apply( log(TWII) , 2 , diff )*100
rt.TWII<-(exp(apply( log(TWII) , 2 , diff ))-1)*100
getSymbols("^FTSE", from = '2012-10-12', to = '2022-10-12')
FTSE<-as.xts(data.frame(FTSE = FTSE[, "FTSE.Adjusted"]))
FTSE<-na.omit(FTSE)
names(FTSE) = c("FTSE")
index(FTSE) = as.Date(index(FTSE))
logrt.FTSE<-apply( log(FTSE) , 2 , diff )*100
rt.FTSE<-(exp(apply( log(FTSE) , 2 , diff ))-1)*100
getSymbols("USDTWD=X", from = '2012-10-12', to = '2022-10-12')
USDTWD<-as.xts(data.frame(`USDTWD=X` = `USDTWD=X`[, paste0("USDTWD=X.Adjusted")]))
USDTWD<-na.omit(USDTWD)
names(USDTWD) = c("USDTWD")
index(USDTWD) = as.Date(index(USDTWD))
USDTWD$USDTWD[578,]<-30.13
logrt.USDTWD<-apply( log(USDTWD) , 2 , diff )*100
rt.USDTWD<-(exp(apply( log(USDTWD) , 2 , diff ))-1)*100
getSymbols("GBPTWD=X", from = '2012-10-12', to = '2022-10-12')
GBPTWD<-as.xts(data.frame(`GBPTWD=X` = `GBPTWD=X`[, paste0("GBPTWD=X.Adjusted")]))
GBPTWD<-na.omit(GBPTWD)
names(GBPTWD) = c("GBPTWD")
index(GBPTWD) = as.Date(index(GBPTWD))
logrt.GBPTWD<-apply( log(GBPTWD) , 2 , diff )*100
rt.GBPTWD<-(exp(apply( log(GBPTWD) , 2 , diff ))-1)*100
getSymbols("USDGBP=X", from = '2012-10-12', to = '2022-10-12')
USDGBP<-as.xts(data.frame(`USDGBP=X` = `USDGBP=X`[, paste0("USDGBP=X.Adjusted")]))
USDGBP<-na.omit(USDGBP)
names(USDGBP) = c("USDGBP")
index(USDGBP) = as.Date(index(USDGBP))
logrt.USDGBP<-apply( log(USDGBP) , 2 , diff )*100
rt.USDGBP<-(exp(apply( log(USDGBP) , 2 , diff ))-1)*100
res<-function(data,name){
acf(data, lag.max = log(length(data)), plot = TRUE,main = paste("ACF","of",name))
pacf(data, plot = TRUE, main = paste("PACF","of",name))
Box.test(data, lag=10, type='Ljung')
}
rttp.SP500=tidy(as.xts(rt.SP500)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#E7B800") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.SP500),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rttp.SP500
res(rt.SP500,"SP500 simple return")
rttp.USDTWD=tidy(as.xts(rt.USDTWD)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#E7B800") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.USDTWD),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rttp.USDTWD
res(rt.USDTWD,"USDTWD simple return")
rttp.GBPTWD=tidy(as.xts(rt.GBPTWD)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(rt.GBPTWD),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
rttp.GBPTWD
modle.MLE(as.numeric(rt.USDTWD))
modle.MLE<-function(data){
m1 = ar(data, method="mle")
m1$aic
m1$order
m2 = arima(data, order=c(m1$order,0,0))
m2
phi0_hat = (1-sum(m2$coef[1:m1$order]))*m2$coef[m1$order+1]
phi0_hat
sqrt(m2$sigma2)
bt<-Box.test(m2$residuals, lag=10, type='Ljung')
tsdiag(m2, gof=floor(log(length(data)))+1,main='ts diag')
p1    = c(1,-m2$coef[1:m1$order])
roots = polyroot(p1)
roots
modulus = Mod(roots)
modulus
k = 2*pi/acos(Re(roots[1])/modulus[1])
k
res<-list()
objs<-c("AIC","mle.order","m1","m2","Residual Box Test","phi0_hat","sigma2","roots","modulus","business cycle")
res.num<-list(m1$aic,m1$order,m1,m2,bt,phi0_hat,sqrt(m2$sigma2),roots ,modulus,k )
for (i in 1:length(res.num)){res[objs[i]] <- res.num[i]}
return(res)
}
logrttp.USDGBP=tidy(as.xts(logrt.USDGBP)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#FC4E07") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.USDGBP),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.USDGBP
logrttp.GBPTWD=tidy(as.xts(logrt.GBPTWD)) %>%
ggplot(aes(x=index,y=value)) + geom_line(color="#2E9FDF") +geom_hline(yintercept = 0,color='black')+
labs(title = paste(colnames(logrt.GBPTWD),"Daily Return for 10 years"),subtitle = "Daily Return",caption = " Time Plot") +
xlab("Date") + ylab("Daily Return in Percentage")
logrttp.GBPTWD
res(logrt.GBPTWD,"GBPTWD log return")
modle.MLE(as.numeric(rt.USDTWD))
m1 = ar(as.numeric(rt.USDTWD),method = "mle")
m1$order
m2 = arima(as.numeric(rt.USDTWD),order = c(m1$order,0,0))
plot(m2$residuals[-length(m2$residuals)], m2$residuals[-1], xlab = expression(paste(epsilon[i])), ylab = expression(paste(epsilon[i+1])))
plot(m2$residuals,as.numeric(rt.USDTWD),xlab="residuals", ylab = "USD/TWD daily return")
modle.MLE(as.numeric(rt.GBPTWD))
m1 = ar(as.numeric(rt.GBPTWD),method = "mle")
m1$order
m2 = arima(as.numeric(rt.GBPTWD),order = c(m1$order,0,0))
plot(m2$residuals[-length(m2$residuals)], m2$residuals[-1], xlab = expression(paste(epsilon[i])), ylab = expression(paste(epsilon[i+1])))
plot(m2$residuals,as.numeric(rt.GBPTWD),xlab="residuals", ylab = "GBP/TWD daily return")
library(zoo)
library(xts)
library(TTR)
library(quantmod)
#plot packages
library(ggplot2)
library(magrittr)
library(broom)
#install.packages("fpp2")                            # Install qpcR package
library(qpcR)
library(fpp2)
#SP500
getSymbols("^GSPC", from ='2012-10-12', to = '2022-10-12')
SP500<-as.xts(data.frame(GSPC = GSPC[, "GSPC.Adjusted"]))
names(SP500) = c("SP500")
index(SP500) = as.Date(index(SP500))
logrt.SP500<-apply( log(SP500) , 2 , diff )*100
test<-data.frame(GSPC = GSPC[, "GSPC.Adjusted"])
View(test)
test<-data.frame(GSPC)
View(test)
rate=function (data){
#處理缺失值
data=data[-which(is.na(data$`data=X.Adjusted`)),]
#設置對數報酬率欄位
data[,7]=as.Date(rownames(data))
data[,8]=rep(0,length(data$`data=X.Open`))
names(data)=c("Open","High","Low","Close","Volume","Adjusted","Date","log return")
par(mfrow = c(2,1))
#都在信賴區間內(藍色線)的，相關性為0
acf(data$Adjusted, lag.max = log(length(data$Adjusted)))
pacf(data$Adjusted)
#(2)
#對數報酬率
for(i in 2:length(data$Adjusted)){
data[i,8]=log(1+(data$Adjusted[i]-data$Adjusted[i-1])/data$Adjusted[i-1])
}
par(mfrow = c(2,1))
acf(data$`log return`, lag.max = log(length(data$`log return`)))
pacf(data$`log return`)
Box.test(data$`log return`, lag=log(10), type='Ljung')
}
rate(test)
#處理缺失值
data<-test
data=data[-which(is.na(data$`data=X.Adjusted`)),]
#設置對數報酬率欄位
data[,7]=as.Date(rownames(data))
data[,8]=rep(0,length(data$`data=X.Open`))
names(data)=c("Open","High","Low","Close","Volume","Adjusted","Date","log return")
par(mfrow = c(2,1))
#都在信賴區間內(藍色線)的，相關性為0
acf(data$Adjusted, lag.max = log(length(data$Adjusted)))
pacf(data$Adjusted)
data$Adjusted
View(data)
#處理缺失值
data<-test
data=data[-which(is.na(data$`data=X.Adjusted`)),]
View(data)
data[-which(is.na(data$`data=X.Adjusted`)),]
-which(is.na(data$`data=X.Adjusted`))
((1230-1160)^2 / 1160)+((357-427)^2 / 427)+((859-930)^2 / 930)+((342-413)^2 / 413)
(((1230-1160)^2) / 1160)+(((357-427)^2) / 427)+(((859-930)^2) / 930)+(((342-413)^2) / 413)
n = 500
r = 1000
q = 1.5
X = c(rep(0,n), rep(1,2*n), rep(0,n))
X
#without correlation
n = 500
r = 200
set.seed(110225007)
for (i in 1:r) {
y11 = rbinom(n,1,f.inv(0.5))
y12 = rbinom(n,1,f.inv(0.7))
y21 = rbinom(n,1,f.inv(1.3))
y22 = rbinom(n,1,f.inv(1.5))
p1[i] = 0
p2[i] = 0
for (j in 1:n) {
if(y11[j]==1 && y12[j]==1)  p1[i] = p1[i]+1
if(y21[j]==1 && y22[j]==1)  p2[i] = p2[i]+1
}
p1[i] = p1[i]/n
p2[i] = p2[i]/n
Y <- c(y11,y12,y21,y22)
D = data.frame(Y,X,Z,G)
lmod <- glm(cbind(Y,1-Y)~X+Z+G, family = binomial, D)
alp[i] = lmod$coefficients[1]
eta[i] = lmod$coefficients[2]
ga[i] = lmod$coefficients[3]
del[i] = lmod$coefficients[4]
lmod.0 <- glm(cbind(Y,1-Y)~Z+G, family = binomial, D)
alp.0[i] = lmod.0$coefficients[1]
ga.0[i] = lmod.0$coefficients[2]
del.0[i] = lmod.0$coefficients[3]}
f <- function(x){
y = log(x/(1-x))
return(y)
}
f.inv <- function(x){
y = exp(x)/(1+exp(x))
return(y)
}
m <- function(x){
y = exp(x)/(1+exp(x))^2
return(y)
}
f <- function(x){
y = log(x/(1-x))
return(y)
}
f.inv <- function(x){
y = exp(x)/(1+exp(x))
return(y)
}
m <- function(x){
y = exp(x)/(1+exp(x))^2
return(y)
}
#without correlation
n = 500
r = 200
q = 1.5
X = c(rep(0,n), rep(1,2*n), rep(0,n))
Z = c(rep(0,n), rep(1,n), rep(0,n), rep(1,n))
G = c(rep(0,2*n), rep(1,2*n))
alp = c()
eta = c()
ga = c()
del = c()
alp.0 = c()
ga.0 = c()
del.0 = c()
p1 <- c()
p2 <- c()
II = 0
VV = 0
I.inv = 0
I.inv_V_I.inv = 0
LR.na1 = 0
LR.rb1 = 0
LR.na2 = 0
LR.rb2 = 0
LRna.lb <- c()
LRna.ub <- c()
LRrb.lb <- c()
LRrb.ub <- c()
LRna.len <- c()
LRrb.len <- c()
S.na1 = 0
S.rb1 = 0
S.na2 = 0
S.rb2 = 0
Sna.lb <- c()
Sna.ub <- c()
Srb.lb <- c()
Srb.ub <- c()
Sna.len <- c()
Srb.len <- c()
W.na1 = 0
W.rb1 = 0
W.na2 = 0
W.rb2 = 0
Wna.lb <- c()
Wna.ub <- c()
Wrb.lb <- c()
Wrb.ub <- c()
Wna.len <- c()
Wrb.len <- c()
set.seed(110225007)
for (i in 1:r) {
y11 = rbinom(n,1,f.inv(0.5))
y12 = rbinom(n,1,f.inv(0.7))
y21 = rbinom(n,1,f.inv(1.3))
y22 = rbinom(n,1,f.inv(1.5))
p1[i] = 0
p2[i] = 0
for (j in 1:n) {
if(y11[j]==1 && y12[j]==1)  p1[i] = p1[i]+1
if(y21[j]==1 && y22[j]==1)  p2[i] = p2[i]+1
}
p1[i] = p1[i]/n
p2[i] = p2[i]/n
Y <- c(y11,y12,y21,y22)
D = data.frame(Y,X,Z,G)
lmod <- glm(cbind(Y,1-Y)~X+Z+G, family = binomial, D)
alp[i] = lmod$coefficients[1]
eta[i] = lmod$coefficients[2]
ga[i] = lmod$coefficients[3]
del[i] = lmod$coefficients[4]
lmod.0 <- glm(cbind(Y,1-Y)~Z+G, family = binomial, D)
alp.0[i] = lmod.0$coefficients[1]
ga.0[i] = lmod.0$coefficients[2]
del.0[i] = lmod.0$coefficients[3]}
View(D)
cbind(Y,1-Y)
rm(list=ls(all=TRUE))
setwd("C:/Users/User/Documents/Study_CrossoverDesign/RCode")
#=============================================
#simulation parameter
#=============================================
sim_time=5000;cor_par=1/6
cros_type=c('ABBA','ABBBAA','AABABABAA','ABCBCACAB','BACACBBCA','BBAACBCAC')
#=============================================
#true value of params with treat-seq-time
#=============================================
param_222=c(0.2,0,-0.7,-0.2)
#=================================================
#Link of Yist:Y11,Y12,Y21,Y22
#row is vector of param,column is x.mat of Yist
#=================================================
#ABBAlog(0.5)
xmat_222=matrix(c(1,1,1,1, 0,1,1,0, 0,1,0,1, 0,0,1,1), nrow = 4, ncol = 4,byrow = TRUE)
mean_true=matrix(c(1.2,0.6,1.0,0.5), nrow = 1, ncol = 4,byrow = TRUE)
#========================================
#Function of output object
#========================================
#Par.values==TrueMean
Mean.True<-function(Par.values,x.mat){  return(exp(Par.values%*%x.mat))}
#Mean.True(Par.values=param_222,x.mat=xmat_222)
#I.true
Matrix.I<-function(cros.type,params,x.mat){
num.seq<-if (nchar(cros.type)==9) 3 else 2
mat.I<- matrix(0, nrow = length(params), ncol = length(params))
Mean<-Mean.True(Par.values=params,x.mat=x.mat)
for (i in 1:length(params) ){ mat.I[i,]<-Mean%*%(t(x.mat)*x.mat[i,])/num.seq}
return(mat.I)
}
#======================================================================
#Generate data
#======================================================================
Data.ind<-function(cros.type,mean.true,seq.size){
num.seq<-if (nchar(cros.type)==9) 3 else 2
data <-  matrix(0, nrow = seq.size, ncol = nchar(cros.type))
for (j in 1:length(mean.true)) {data[,j] =rpois(seq.size, lambda = mean.true[1,j])}
return(data)
}
#--------------------------------------------------------------------
Data.cor<-function(cros.type,mean.true,seq.size,cor.par){
num.seq<-if (nchar(cros.type)==9) 3 else 2
nui<-replicate(2,rgamma(n=seq.size,shape=1/cor.par,scale=cor.par))
mean.seq<-matrix(mean.true,ncol=nchar(cros.type)/num.seq,nrow=num.seq)
mean.cor<-list();data <-matrix(0, nrow = seq.size, ncol = nchar(cros.type))
for (i in 1:num.seq){
m<-split(c(outer(nui[,i],mean.seq[,i],  function(x, y) x * y)), ceiling(seq_along(c(outer(nui[,i],mean.seq[,i],  function(x, y) x * y)))/seq.size))
mean.cor<-append(mean.cor,m)
}
mean.cor<- t(matrix(unlist(mean.cor), ncol = seq.size, byrow = TRUE))
for (i in 1:nchar(cros.type)){
list_poisson <- unlist(lapply(mean.cor[,i], FUN = function(x, y) rpois(y, x), y = 1))
data[,i]<-list_poisson
}
return(data)
}
#simulation for ABBA
seq=150
Data.ind(cros.type = cros_type[1],mean.true =mean_true,seq.size = seq )
data.ind<-Data.ind(cros.type = cros_type[1],mean.true =mean_true,seq.size = seq )
View(data.ind)
data_long = reshape(data.ind, direction="long", varying = list(c("V1", "V2", "V3", "V4")), v.names = c("Y")) # 利用 reshape 函數將資料從 wide 轉成 long
data_long = reshape(data.ind, direction="long", varying = list(c("V1", "V2", "V3", "V4")), v.names = c("Y")data_long = reshape(data, direction="long", varying = list(c("v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10"), c("w0", "w1", "w2", "w3", "w4", "w5", "w6", "w7", "w8", "w9", "w10"), c("x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10")), v.names = c("v", "w", "x"), idvar = "id") # 利用 reshape 函數將資料從 wide 轉成 long
Y <- c(data.ind[,1],data.ind[,2],data.ind[,3],data.ind[,4])
X = c(rep(0,seq), rep(1,2*seq), rep(0,seq))
Z = c(rep(0,seq), rep(1,seq), rep(0,seq), rep(1,seq))
G = c(rep(0,2*seq), rep(1,2*seq))
D = data.frame(Y,X,Z,G)
;mod < - glm(Y ~ X + Z + G, data, family = poisson(link = "log"))
lmod < - glm(Y ~ X + Z + G, data, family = poisson(link = "log"))
lmod < - glm(Y ~ X + Z + G, data, family = poisson(link = "log"))
glm(Y ~ X + Z + G, data, family = poisson(link = "log"))
lmod < - glm(Y ~ X + Z + G, D, family = poisson(link = "log"))
D = data.frame(Y,X,Z,G)
glm(Y ~ X + Z + G, family = poisson(link = "log"), D)
lmod$coefficients[1]
lmod < - glm(Y ~ X + Z + G, family = poisson(link = "log"), D)
lmod <- glm(Y ~ X + Z + G, family = poisson(link = "log"), D)
lmod$coefficients[1]
