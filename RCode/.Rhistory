A = i.ee - i.ep %*% solve(i.pp) %*% t(i.ep)
v.pe = matrix(c(v.te, v.eg, v.ed), nrow = 3)
v.pp = matrix(c(v.tt, v.tg, v.td, v.tg, v.gg, v.gd, v.td,
v.gd, v.td), nrow = 3, ncol = 3)
B = v.ee - 2 * i.ep %*% solve(i.pp) %*% v.pe +
i.ep %*% solve(i.pp) %*% v.pp %*% solve(i.pp) %*% t(i.ep)
var.na[i]<-1/A
var.rb[i]<-B/A/A
#=================================================
#wald test
#=================================================
wna = log(eta[i]) * A * log(eta[i]) * 2*seq
wrb = log(eta[i]) * A^2 / B * log(eta[i]) * 2*seq
if( wna<=qchisq(0.95, 1) )  W.na1 = W.na1+1
if( wrb<=qchisq(0.95, 1) )  W.rb1 = W.rb1+1
#--------------------------------------------
#LR confidence interval
#--------------------------------------------
l<-function(par){
ll=sum(par[1]*y11-exp(par[1])+(par[1]+par[2]+par[3])*y12-exp(par[1]+par[2]+par[3]))+
sum((par[1]+par[2]+par[4])*y21-exp(par[1]+par[2]+par[4])+ (par[1]+par[3]+par[4])*y22-exp(par[1]+par[3]+par[4]))
return(ll)
}
#null MLE:用GLE算null之下的MLE
Y <- c(y11,y12,y21,y22)
df.ind = data.frame(Y,X,Z,G)
mod.0 <- glm(Y ~ Z + G, family = poisson(link = "log"), df.ind)
tao.0[i]<-exp(mod.0$coefficients[1])
gam.0[i]<-exp(mod.0$coefficients[2])
del.0[i]<-exp(mod.0$coefficients[3])
#計算null cov
cov1<-mean( (y11-tao.0[i])*(y12-tao.0[i]*gam.0[i]) )
cov2<-mean( (y21-tao.0[i]*del.0[i])*(y22-tao.0[i]*gam.0[i]*del.0[i]) )
i0.tt<-( tao.0[i]+tao.0[i]*gam.0[i] + tao.0[i]*del[i]+tao[i]*gam[i]*del[i] )/2
i0.gg<-( tao.0[i]*gam.0[i] + tao.0[i]*gam.0[i]*del.0[i] )/2
i0.ee<-( tao.0[i]*gam.0[i] + tao.0[i]*del.0[i] )/2
i0.dd<- ( tao.0[i]*del.0[i]+tao.0[i]*gam.0[i]*del.0[i] )/2
i0.eg<- ( tao.0[i]*gam.0[i] )/2
i0.ed<- ( tao.0[i]*del.0[i] )/2
i0.gd<- ( tao.0[i]*gam.0[i]*del.0[i] )/2
v0.tt = i0.tt + cov1+cov2
v0.ee = i0.ee
v0.gg = i0.gg
v0.dd.0 = i0.dd + cov2
v0.te = i0.ee + cov1/2+cov2/2
v0.tg = i0.gg + cov1/2+cov2/2
v0.td = i0.dd + cov2
v0.eg = i0.eg + cov2/2
v0.ed = i0.ed + cov2/2
v0.gd = i0.gd + cov2/2
i0.ep = matrix(c(i0.ee, i0.eg, i0.ed), ncol = 3)
i0.pp = matrix(c(i0.tt, i0.gg, i0.dd, i0.gg, i0.gg, i0.gd,
i0.dd, i0.gd, i0.dd), nrow = 3, ncol = 3)
A0 = i0.ee - i0.ep %*% solve(i0.pp) %*% t(i0.ep)
v0.pe = matrix(c(v0.te, v0.eg, v0.ed), nrow = 3)
v0.pp = matrix(c(v0.tt, v0.tg, v0.td, v0.tg, v0.gg, v0.gd, v0.td,
v0.gd, v0.td), nrow = 3, ncol = 3)
B0 = v0.ee - 2 * i0.ep %*% solve(i0.pp) %*% v0.pe +
i0.ep %*% solve(i0.pp) %*% v0.pp %*% solve(i0.pp) %*% t(i0.ep)
l1 = l(log(c(tao[i], eta[i], gam[i], del[i])) )
l0 = l(log(c(tao.0[i], 1, gam.0[i], del.0[i])))
if( (2*(l1-l0))<=qchisq(0.95, 1) )  LR.na1 = LR.na1+1
if( (2*A/B*(l1-l0))<=qchisq(0.95, 1) )  LR.rb1 = LR.rb1+1
LR.na<-Vectorize( function(e) return(2*(l(log(c(tao[i], eta[i], gam[i], del[i])) )-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
LR.naup[i] = uniroot(LR.na, c(log(eta[i])-1,log(eta[i])))$root
LR.nalw[i] = uniroot(LR.na, c(log(eta[i]),log(eta[i])+1))$root
LRna.len[i] = LR.naup[i] - LR.nalw[i]
LR.rb<-Vectorize( function(e) return(2*A/B*(l(log(c(tao[i], eta[i], gam[i], del[i])) )-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
LR.rbup = uniroot(LR.rb, c(log(eta[i])-1,log(eta[i])))$root
LR.rblw = uniroot(LR.rb, c(log(eta[i]),log(eta[i])+1))$root
LRrb.len[i] = LR.rbup[i] - LR.rblw [i]
#--------------------------------------------
#wald confidence interval
#--------------------------------------------
#W.eta = Vectorize( function(e) return( (e-log(eta[i]))^2 ))
W.na = Vectorize( function(e) return(2*seq * (log(eta[i])-e)^2 * A0 - qchisq(0.95, 1)))
#lower and upper
W.naup[i]<-uniroot(W.na,c(log(eta[i]),log(eta[i])+1))$root
W.nalw[i]<-uniroot(W.na,c(log(eta[i])-1,log(eta[i])))$root
Wna.len[i] = W.naup[i] -  W.nalw[i]
Wna.cp[i] = ifelse((W.nalw[i] < 0 & W.naup[i] > 0), 1, 0)
W.rb = Vectorize( function(e) return(2*seq * (log(eta[i])-e)^2 * A0^2/B0 - qchisq(0.95, 1)))
W.rbup[i]<-uniroot(W.rb,c(log(eta[i]),log(eta[i])+1))$root
W.rblw[i]<-uniroot(W.rb,c(log(eta[i])-1,log(eta[i])))$root
Wrb.len[i] = W.rbup[i] -  W.rblw[i]
Wrb.cp[i] = ifelse((W.rblw[i] < 0 & W.rbup[i] > 0), 1, 0)
}
curve(W.na,-1,1, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "Wald")
abline(h = qchisq(0.95, df = 1)*A0, lwd = 2, col = "red")
curve(W.na,-0.5,0.5, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "Wald")
abline(h = qchisq(0.95, df = 1)*A0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
curve(W.na,-0.5,0.5, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "Wald")
abline(h = qchisq(0.95, df = 1)*A0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
curve(W.rb,-0.5,0.5, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "Wald")
abline(h = qchisq(0.95, df = 1)*A0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
curve(W.rb,-0.5,0.5, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "Wald")
abline(h = qchisq(0.95, df = 1)*A0^2/B0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
log(eta[i])
uniroot(W.rb,c(log(eta[i]),log(eta[i])+0.3))$root
uniroot(W.rb,c(log(eta[i])-0.3,log(eta[i])))$root
uniroot(W.na,c(log(eta[i]),log(eta[i])+0.3))$root
uniroot(W.na,c(log(eta[i])-0.3,log(eta[i])))$root
qchisq(0.95, 1)
qchisq(0.97.5, 1)
qchisq(0.975, 1)
qchisq(0.925, 1)
curve(LR.rb,-0.5,0.5, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A0^2/B0, lwd = 2, col = "red")
curve(LR.rb,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A0^2/B0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
curve(LR.na,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A0, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
LR.na <- function(e){
mod.0 <- glm(formula = Y~Z+G+offset(e*X),
family = poisson, data = df.ind)
a = mod.0$coefficients[1]
g = mod.0$coefficients[2]
d = mod.0$coefficients[3]
l.0 = lik(c(a, e, g, d))
u = 2*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i])-1,log(eta[i])))$root
LR.na<-Vectorize( function(e) return(2*(l(log(c(tao[i], eta[i], gam[i], del[i])) )-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
LR.na <- function(e){
mod.0 <- glm(formula = Y~Z+G+offset(e*X),
family = poisson, data = df.ind)
a = mod.0$coefficients[1]
g = mod.0$coefficients[2]
d = mod.0$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i])-1,log(eta[i])))$root
LR.naup[i]
LR.na <- function(e){
mod.0 <- glm(formula = Y~Z+G+offset(e*X),
family = poisson, data = df.ind)
a = exp(mod.0$coefficients[1])
g = exp(mod.0$coefficients[2])
d = exp(mod.0$coefficients[3])
l.0 = l(c(a, e, g, d))
u = 2*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i])-1,log(eta[i])))$root
curve(LR.na,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
uniroot(LR.na, c(log(eta[i])-2,log(eta[i])))$root
log(eta[i])
l1
LR.na
uniroot(LR.na, c(log(eta[i])-1.5,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))
mod.0 <- glm(formula = Y~Z+G+offset(e*X),
family = poisson, data = df.ind)
uniroot(LR.na, c(log(eta[i])-4,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i])-4,log(eta[i])+2))$root
uniroot(LR.na, c(log(eta[i])-4,log(eta[i])+4))$root
LR.na<-Vectorize( function(e) return(-2*(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
curve(LR.na,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
LR.na <- function(e){
mod.0 <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = exp(mod.0$coefficients[1])
g = exp(mod.0$coefficients[2])
d = exp(mod.0$coefficients[3])
l.0 = l(c(a, e, g, d))
u = 2*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i])-4,log(eta[i])+4))$root
uniroot(LR.na, c(0,0.2))$root
uniroot(LR.na, c(-0.2,0.2))$root
log(eta[i])
uniroot(LR.na, c(-0.03,0.1))$root
uniroot(LR.na, c(-0.02,0.1))$root
uniroot(LR.na, c(-0.01,0.1))$root
mod.0 <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
LR.na <- function(e){
mod.0 <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod.0$coefficients[1]
g = mod.0$coefficients[2]
d = mod.0$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta.0[i]),log(eta.0[i])+1))$root
uniroot(LR.na, c(log(eta[i]),log(eta[i])+1))$root
uniroot(LR.na, c(log(eta[i])-1,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.2))$root
curve(LR.na,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
LR.na<-Vectorize( function(e) return(2*(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.2))$root
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.3))$root
uniroot(LR.rb, c(log(eta[i])-0.3,log(eta[i])))$root
uniroot(LR.rb, c(log(eta[i])-0.2,log(eta[i])))$root
uniroot(LR.rb, c(log(eta[i])-0.1,log(eta[i])))$root
a = mod.0$coefficients[1]
log(eta[i])
LR.na<-Vectorize( function(e) return(2*(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.3))$root
uniroot(LR.rb, c(log(eta[i])-0.4,log(eta[i])))$root
uniroot(LR.rb, c(log(eta[i])-0.1,log(eta[i])))$root
uniroot(LR.rb, c(log(eta[i]),log(eta[i]))+0.1)$root
uniroot(LR.na, c(log(eta[i])-0.3,log(eta[i])))$root
LR.rb<-Vectorize( function(e) return(2* A/B *(l(log(c(tao[i], eta[i], gam[i], del[i])) )-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.3))$root
uniroot(LR.rb, c(log(eta[i])-0.3,log(eta[i])))$root
curve(LR.rb,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A^2/B, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.15))$root
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.2))$root
LR.rb <- function(e){
mod.0 <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod.0$coefficients[1]
g = mod.0$coefficients[2]
d = mod.0$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*A/B*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.2))$root
uniroot(LR.rb, c(log(eta[i])-0.15,log(eta[i])))$root
log(eta[i])
LR.rb<-Vectorize( function(e) return(2* A/B *(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.2))$root
LR.rb <- function(e){
mod.0 <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod.0$coefficients[1]
g = mod.0$coefficients[2]
d = mod.0$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*A/B*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.15))$root
uniroot(LR.rb, c(log(eta[i])-0.15,log(eta[i])))$root
LR.na <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2 * (l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.2))$root
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.15))$root
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
LR.rb <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*A/B*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.15))$root
uniroot(LR.rb, c(log(eta[i])-0.15,log(eta[i])))$root
rm(list=ls(all=TRUE))
require(faraway)
require(numDeriv)
require(MASS)
require(extraDistr)
require(simstudy)
setwd("C:/Users/User/Documents/Study_CrossoverDesign/RCode")
#===========================================================
#參數說明
# - sim_time:模擬次數
# - cor_par:用random effect生成相關性資料的參數Gamma(alpha,beta)的beta(alpha*beta=1)
# - seq:每組人數，AB一組BA一組，共兩組。
# - param:參數真值(tao,eta(treatment effect),gamma(period effect),delta(sequence effect))
# - xmat:自變量的值
# - mean.true:平均數.真值
# - X、Z、G:自變量，用來fit glm
#===========================================================
sim_time=10000;seq=100
param=c(1.2,0,1.0,0.2)#c(1.2,0,1.0,0.2)#c(0.3,0,0.4,-1.0)
xmat=matrix(c(1,1,1,1, 0,1,1,0, 0,1,0,1, 0,0,1,1), nrow = 4, ncol = 4,byrow = TRUE)
mean.true=exp(param%*%xmat)
X = c(rep(0,seq), rep(1,2*seq), rep(0,seq))
Z = c(rep(0,seq), rep(1,seq), rep(0,seq), rep(1,seq))
G = c(rep(0,2*seq), rep(1,2*seq))
MLE.optim<-matrix(0, nrow = sim_time, ncol = 4)
MLE.glm<-matrix(0, nrow = sim_time, ncol = 4)
MLE.closeform<-matrix(0, nrow = sim_time, ncol = 4)
invI.optim=0;I.glm=0;I.optim=0;invI.glm=0
I.cf=0;V.cf=0;invI.closeform=0;I0.cf=0;V0.cf=0;invI0.closeform=0
tao<-c();eta<-c();gam<-c();del<-c()
tao.0<-c();eta.0<-c();gam.0<-c();del.0<-c()
W.na1<-0;W.rb1<-0;LR.na1<-0;LR.rb1<-0;S.na1<-0;S.rb1<-0
W.naup<-c();W.nalw<-c();Wna.len<-c();Wna.cp<-c()
W.rbup<-c();W.rblw<-c();Wrb.len<-c();Wrb.cp<-c()
LR.naup<-c();LR.nalw<-c();LRna.len<-c();LRna.cp<-c()
LR.rbup<-c();LR.rblw<-c();LRrb.len<-c();LRrb.cp<-c()
eta.var<-c();var.na<-c();var.rb<-c()
#========================================================
#independent data
#========================================================
set.seed(110225021)
for (i in 1:sim_time){
#mean=r*(1-p)/p用負二項分配生成個數型資料
# y11<-rnbinom(n = seq, size = 2, prob = 0.6)
# y12<-rnbinom(n = seq, size = 3, prob = 0.6)
# y21<-rnbinom(n = seq, size = 2, prob = 0.8)
# y22<-rnbinom(n = 100000, size = 3, prob = 0.8)
# Y <- c(y11,y12,y21,y22)
#用卜瓦松分配生成個數型資料
y11<-rpois(seq, lambda = mean.true[1])
y12<-rpois(seq, lambda = mean.true[2])
y21<-rpois(seq, lambda = mean.true[3])
y22<-rpois(seq, lambda = mean.true[4])
#-------------------------------------------------------
#closeform MLE:exp(.)估計量為指數形式e.g. eta[i]=exp(eta)
#-------------------------------------------------------
tao[i]<-mean(y11)
eta[i]<-sqrt( sum(y12)*sum(y21)/(sum(y11)*sum(y22)) )
gam[i]<-sqrt( sum(y12)*sum(y22)/(sum(y11)*sum(y21)) )
del[i]<-sqrt( sum(y21)*sum(y22)/(sum(y11)*sum(y12)) )
#Matrix I & Matrix V
i.tt<-( tao[i]+tao[i]*eta[i]*gam[i] + tao[i]*eta[i]*del[i]+tao[i]*gam[i]*del[i] )/2
i.gg<-( tao[i]*eta[i]*gam[i] + tao[i]*gam[i]*del[i] )/2
i.ee<-( tao[i]*eta[i]*gam[i] + tao[i]*eta[i]*del[i] )/2
i.dd<- ( tao[i]*eta[i]*del[i]+tao[i]*gam[i]*del[i] )/2
i.eg<- ( tao[i]*eta[i]*gam[i] )/2
i.ed<- ( tao[i]*eta[i]*del[i] )/2
i.gd<- ( tao[i]*gam[i]*del[i] )/2
I<-matrix(c(i.tt,i.ee,i.gg,i.dd,
i.ee,i.ee,i.eg,i.ed,
i.gg,i.eg,i.gg,i.gd,
i.dd,i.ed,i.gd,i.dd),nrow=4, ncol=4, byrow = TRUE)
I.cf<-I.cf+I
invI.closeform <- invI.closeform + solve(I)
#確認covariance和R計算的covariance是否相同，下方的V用自己算的covariance而非R內建的
cov1<-mean( (y11-tao[i])*(y12-tao[i]*eta[i]*gam[i]) )
cov2<-mean( (y21-tao[i]*eta[i]*del[i])*(y22-tao[i]*gam[i]*del[i]) )
v.tt = i.tt + cov1+cov2
v.ee = i.ee
v.gg = i.gg
v.dd = i.dd + cov2
v.te = i.ee + cov1/2+cov2/2
v.tg = i.gg + cov1/2+cov2/2
v.td = i.dd + cov1
v.eg = i.eg + cov2/2
v.ed = i.ed + cov2/2
v.gd = i.gd + cov2/2
V.cf<-V.cf+matrix( c(v.tt, v.te, v.tg, v.td,
v.te, v.ee, v.eg, v.ed,
v.tg, v.eg, v.gg, v.gd,
v.td, v.ed, v.gd, v.td),nrow=4, ncol=4, byrow = TRUE)
#計算AB矩陣
i.ep = matrix(c(i.ee, i.eg, i.ed), ncol = 3)
i.pp = matrix(c(i.tt, i.gg, i.dd, i.gg, i.gg, i.gd,
i.dd, i.gd, i.dd), nrow = 3, ncol = 3)
A = i.ee - i.ep %*% solve(i.pp) %*% t(i.ep)
v.pe = matrix(c(v.te, v.eg, v.ed), nrow = 3)
v.pp = matrix(c(v.tt, v.tg, v.td, v.tg, v.gg, v.gd, v.td,
v.gd, v.td), nrow = 3, ncol = 3)
B = v.ee - 2 * i.ep %*% solve(i.pp) %*% v.pe +
i.ep %*% solve(i.pp) %*% v.pp %*% solve(i.pp) %*% t(i.ep)
var.na[i]<-1/A
var.rb[i]<-B/A/A
#=================================================
#wald test
#=================================================
wna = log(eta[i]) * A * log(eta[i]) * 2*seq
wrb = log(eta[i]) * A^2 / B * log(eta[i]) * 2*seq
if( wna<=qchisq(0.95, 1) )  W.na1 = W.na1+1
if( wrb<=qchisq(0.95, 1) )  W.rb1 = W.rb1+1
#--------------------------------------------
#LR confidence interval
#--------------------------------------------
l<-function(par){
ll=sum(par[1]*y11-exp(par[1])+(par[1]+par[2]+par[3])*y12-exp(par[1]+par[2]+par[3]))+
sum((par[1]+par[2]+par[4])*y21-exp(par[1]+par[2]+par[4])+ (par[1]+par[3]+par[4])*y22-exp(par[1]+par[3]+par[4]))
return(ll)
}
#null MLE:用GLE算null之下的MLE
Y <- c(y11,y12,y21,y22)
df.ind = data.frame(Y,X,Z,G)
mod.0 <- glm(Y ~ Z + G, family = poisson(link = "log"), df.ind)
tao.0[i]<-exp(mod.0$coefficients[1])
gam.0[i]<-exp(mod.0$coefficients[2])
del.0[i]<-exp(mod.0$coefficients[3])
#計算null cov
cov1<-mean( (y11-tao.0[i])*(y12-tao.0[i]*gam.0[i]) )
cov2<-mean( (y21-tao.0[i]*del.0[i])*(y22-tao.0[i]*gam.0[i]*del.0[i]) )
i0.tt<-( tao.0[i]+tao.0[i]*gam.0[i] + tao.0[i]*del[i]+tao[i]*gam[i]*del[i] )/2
i0.gg<-( tao.0[i]*gam.0[i] + tao.0[i]*gam.0[i]*del.0[i] )/2
i0.ee<-( tao.0[i]*gam.0[i] + tao.0[i]*del.0[i] )/2
i0.dd<- ( tao.0[i]*del.0[i]+tao.0[i]*gam.0[i]*del.0[i] )/2
i0.eg<- ( tao.0[i]*gam.0[i] )/2
i0.ed<- ( tao.0[i]*del.0[i] )/2
i0.gd<- ( tao.0[i]*gam.0[i]*del.0[i] )/2
v0.tt = i0.tt + cov1+cov2
v0.ee = i0.ee
v0.gg = i0.gg
v0.dd.0 = i0.dd + cov2
v0.te = i0.ee + cov1/2+cov2/2
v0.tg = i0.gg + cov1/2+cov2/2
v0.td = i0.dd + cov2
v0.eg = i0.eg + cov2/2
v0.ed = i0.ed + cov2/2
v0.gd = i0.gd + cov2/2
i0.ep = matrix(c(i0.ee, i0.eg, i0.ed), ncol = 3)
i0.pp = matrix(c(i0.tt, i0.gg, i0.dd, i0.gg, i0.gg, i0.gd,
i0.dd, i0.gd, i0.dd), nrow = 3, ncol = 3)
A0 = i0.ee - i0.ep %*% solve(i0.pp) %*% t(i0.ep)
v0.pe = matrix(c(v0.te, v0.eg, v0.ed), nrow = 3)
v0.pp = matrix(c(v0.tt, v0.tg, v0.td, v0.tg, v0.gg, v0.gd, v0.td,
v0.gd, v0.td), nrow = 3, ncol = 3)
B0 = v0.ee - 2 * i0.ep %*% solve(i0.pp) %*% v0.pe +
i0.ep %*% solve(i0.pp) %*% v0.pp %*% solve(i0.pp) %*% t(i0.ep)
l1 = l(log(c(tao[i], eta[i], gam[i], del[i])) )
l0 = l(log(c(tao.0[i], 1, gam.0[i], del.0[i])))
if( (2*(l1-l0))<=qchisq(0.95, 1) )  LR.na1 = LR.na1+1
if( (2*A/B*(l1-l0))<=qchisq(0.95, 1) )  LR.rb1 = LR.rb1+1
LR.na <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2 * (l1-l.0) - qchisq(0.95, 1)
return(u)
}
# LR.na<-Vectorize( function(e) return(2*(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
LR.naup[i] = uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.2))$root
LR.nalw[i] = uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
LRna.len[i] = LR.naup[i] - LR.nalw[i]
LR.rb <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*A/B*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
#LR.rb<-Vectorize( function(e) return(2* A/B *(l1-l(log(c(tao.0[i], exp(e), gam.0[i], del.0[i])))) - qchisq(0.95, 1)))
LR.rbup[i] = uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.15))$root
LR.rblw[i] = uniroot(LR.rb, c(log(eta[i])-0.15,log(eta[i])))$root
LRrb.len[i] = LR.rbup[i] - LR.rblw [i]
#--------------------------------------------
#wald confidence interval
#--------------------------------------------
#W.eta = Vectorize( function(e) return( (e-log(eta[i]))^2 ))
W.na = Vectorize( function(e) return(2*seq * (log(eta[i])-e)^2 * A0 - qchisq(0.95, 1)))
#lower and upper
W.naup[i]<-uniroot(W.na,c(log(eta[i]),log(eta[i])+0.3))$root
W.nalw[i]<-uniroot(W.na,c(log(eta[i])-0.3,log(eta[i])))$root
Wna.len[i] = W.naup[i] -  W.nalw[i]
Wna.cp[i] = ifelse((W.nalw[i] < 0 & W.naup[i] > 0), 1, 0)
W.rb = Vectorize( function(e) return(2*seq * (log(eta[i])-e)^2 * A0^2/B0 - qchisq(0.95, 1)))
W.rbup[i]<-uniroot(W.rb,c(log(eta[i]),log(eta[i])+0.3))$root
W.rblw[i]<-uniroot(W.rb,c(log(eta[i])-0.3,log(eta[i])))$root
Wrb.len[i] = W.rbup[i] -  W.rblw[i]
Wrb.cp[i] = ifelse((W.rblw[i] < 0 & W.rbup[i] > 0), 1, 0)
curve(LR.rb,-0.2,0.2, n = 1000, lwd =3, col = "blue", cex.axis = 2, cex.lab = 1.5, main =  expression(paste("Wald function of ", mu), ylim = c(0,1)),
xlab = ~mu, ylab = "LR")
abline(h = qchisq(0.95, df = 1)*A^2/B, lwd = 2, col = "red")
abline(v = log(eta[i]), lwd = 2, col = "purple", lty = 2)
}
LR.na <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2 * (l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.na, c(log(eta[i]),log(eta[i])+0.2))$root
uniroot(LR.na, c(log(eta[i])-0.2,log(eta[i])))$root
LR.rb <- function(e){
mod <- glm(Y ~ Z + G + offset(e*X), family = poisson(link = "log"), df.ind)
a = mod$coefficients[1]
g = mod$coefficients[2]
d = mod$coefficients[3]
l.0 = l(c(a, e, g, d))
u = 2*A/B*(l1-l.0) - qchisq(0.95, 1)
return(u)
}
uniroot(LR.rb, c(log(eta[i]),log(eta[i])+0.15))$root
uniroot(LR.rb, c(log(eta[i])-0.15,log(eta[i])))$root
View(df.ind)
